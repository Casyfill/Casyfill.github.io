<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>City fish</title><link href="http://casyfill.github.io/" rel="alternate"></link><link href="http://casyfill.github.io/feeds/blog.atom.xml" rel="self"></link><id>http://casyfill.github.io/</id><updated>2016-08-10T00:00:00-04:00</updated><entry><title>just MAKE it</title><link href="http://casyfill.github.io/posts/2016/08/just-make-it/" rel="alternate"></link><updated>2016-08-10T00:00:00-04:00</updated><author><name>Philipp Kats</name></author><id>tag:casyfill.github.io,2016-08-10:posts/2016/08/just-make-it/</id><summary type="html">&lt;p&gt;You should always be able to explain what you're doing to your grandma.&lt;/p&gt;
&lt;p&gt;To display line numbers, use a path-less shebang instead of colons:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;The path-less shebang syntax *will* show line numbers.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;At least, so do they say. However, when your product is literally a bunch of scripts that just DO something, it becomes hard to explain how to use it not only to your client or colleague - even by yourself, you'll find it hard to remember all the aspects and commands a few weeks later.&lt;/p&gt;
&lt;p&gt;Of course, that is why we use user interfaces - GUI represents all set of commands and operations you have, as well as current status, data, etc, etc. GUI is fun; Most of the time, however,  you don't have time nor budget to develop a good one.&lt;/p&gt;
&lt;p&gt;Because of this, and a few other reasons, you probably want to stick with command line. Yet again, command line is great, but it is quite hard to remember and tedious to repeat - especially if process requires a combination of scripts to be run with different settings ( I will definitely write another post on writing your CLI interface with &lt;a href="https://github.com/docopt/docopt"&gt;docopts&lt;/a&gt; another time). And explaining that to your grandma (colleague, boss, client)... they will definitely remember, whom to blame for all this anxiety with commands they have.&lt;/p&gt;
&lt;p&gt;So, what we gonna do? I'd say, MAKE. MAKE is a tool that is preinstalled already on any mac or linux system. All you have to do, is to create a &lt;code&gt;Makefile&lt;/code&gt; in the right directory, and then describe all functions - rules -  within this file. For example, consider having a &lt;code&gt;Makefile&lt;/code&gt; with this code in your folder:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;hello&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    @echo &lt;span class="s1"&gt;&amp;#39;Hello world!&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Note: the &lt;tab&gt; in the command line is necessary for make to work. Now, enter &lt;code&gt;make hello&lt;/code&gt; in the command line. If everything is correct, program will print &lt;code&gt;Hello world!&lt;/code&gt; as you'd expect it.&lt;/p&gt;
&lt;p&gt;Same way, you can run any bash command, python script with parameters, or other tool (think git, for example).
The beauty is, those commands will work for anyone on any UNIX machine, and the &lt;code&gt;Makefile&lt;/code&gt; is simple enough for anyone to reed and understand.&lt;/p&gt;
&lt;p&gt;Makefiles were created to simplify compiling C code into binary. Generally, every rule in the Makefile should follow
this pattern:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;target&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;dependencies&lt;/span&gt;
&lt;span class="err"&gt;[tab]&lt;/span&gt; &lt;span class="err"&gt;system&lt;/span&gt; &lt;span class="err"&gt;command&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;However, for our python-data practice, we rarely need target files.
In fact, as we don't need any files, we should state our commands as .PHONY. A phony target is one that is not really the name of a file; rather it is just a name for a recipe to be executed when you make an explicit request. There are two reasons to use a phony target: to avoid a conflict with a file of the same name, and to improve performance.
In order to do so, just add a declaration:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;.PHONY&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;hello&lt;/span&gt;

&lt;span class="nf"&gt;hello&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
  @echo &lt;span class="s1"&gt;&amp;#39;Hello world!&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You also can define common variables and keep comments (here I use example from GNU Make documentation):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c"&gt;# target file&lt;/span&gt;
&lt;span class="nv"&gt;TARGET&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; myprog

&lt;span class="nf"&gt;all&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;TARGET&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;$(&lt;/span&gt;TARGET&lt;span class="k"&gt;)&lt;/span&gt;: &lt;span class="k"&gt;$(&lt;/span&gt;TARGET&lt;span class="k"&gt;)&lt;/span&gt;.c
  &lt;span class="k"&gt;$(&lt;/span&gt;CC&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;CFLAGS&lt;span class="k"&gt;)&lt;/span&gt; -o &lt;span class="k"&gt;$(&lt;/span&gt;TARGET&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;TARGET&lt;span class="k"&gt;)&lt;/span&gt;.c

&lt;span class="nf"&gt;clean&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="k"&gt;$(&lt;/span&gt;RM&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;TARGET&lt;span class="k"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Sometimes, you want to add a parameter (for example, folder name) from the shell. Generally, it is a bad practice, as things start to be complicated again. However, you can declare a variable in the file, then pass it's value from the shell:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$make&lt;/span&gt; target &lt;span class="nv"&gt;FOO&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;bar
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Practice&lt;/h2&gt;
&lt;p&gt;Lets take more practical example: I want to create a template project in my root folder, and I am tired of doing it manually. Lets write the following in our &lt;code&gt;Makefile&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;.PHONY&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;project&lt;/span&gt;

&lt;span class="nf"&gt;project&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    mkdir project&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nb"&gt;cd&lt;/span&gt; project&lt;span class="p"&gt;;&lt;/span&gt; mkdir outbox&lt;span class="p"&gt;;&lt;/span&gt; mkdir inbox&lt;span class="p"&gt;;&lt;/span&gt; mkdir code&lt;span class="p"&gt;;&lt;/span&gt; mkdir data&lt;span class="p"&gt;;&lt;/span&gt; touch README.md&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And our main command is done. however, if I want to specify another version of template, say, for data visualisation,
I can add another command:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;project&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    mkdir project&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nb"&gt;cd&lt;/span&gt; project&lt;span class="p"&gt;;&lt;/span&gt; mkdir outbox&lt;span class="p"&gt;;&lt;/span&gt; mkdir inbox&lt;span class="p"&gt;;&lt;/span&gt; mkdir code&lt;span class="p"&gt;;&lt;/span&gt; mkdir data&lt;span class="p"&gt;;&lt;/span&gt; touch README.md&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="nf"&gt;dataviz&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;project&lt;/span&gt;;
    &lt;span class="nb"&gt;cd&lt;/span&gt; project&lt;span class="p"&gt;;&lt;/span&gt; mkdir assets&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nb"&gt;cd&lt;/span&gt; assets&lt;span class="p"&gt;;&lt;/span&gt; mkdir fonts&lt;span class="p"&gt;;&lt;/span&gt; mkdir img&lt;span class="p"&gt;;&lt;/span&gt; mkdir icons&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nb"&gt;cd&lt;/span&gt; project&lt;span class="p"&gt;;&lt;/span&gt; mkdir js&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nb"&gt;cd&lt;/span&gt; js&lt;span class="p"&gt;;&lt;/span&gt; git clone git@github.com:d3/d3.git&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And now we have another template, which adds D3 library. NOTE: It might be more sufficient to define your templates as different branches of the same repository on the github, and use Makefile just as an interface to clone them and drop the git link.&lt;/p&gt;
&lt;p&gt;Similarly, you can wrap your complex data product into bunch of simple commands. My Foursquare scraper, for example, is described with:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;print status&lt;/li&gt;
&lt;li&gt;run scraper&lt;/li&gt;
&lt;li&gt;dump data to csv&lt;/li&gt;
&lt;li&gt;clean all data&lt;/li&gt;
&lt;li&gt;report data statistics&lt;/li&gt;
&lt;li&gt;show a log&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Of course, this interface does not reduce your actual flexibility, as code is unchanged - you only define the most common cases.&lt;/p&gt;
&lt;p&gt;For more information on Makefiles, check&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://mrbook.org/blog/tutorials/make/"&gt;Makefiles. Tutorial by example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.cs.swarthmore.edu/~newhall/unixhelp/howto_makefiles.html"&gt;GNU: Using make and writing Makefiles&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="interface"></category><category term="CLI"></category></entry><entry><title>Dashboard up and running. Part I</title><link href="http://casyfill.github.io/posts/2016/04/dashboard-up-and-running-part-i/" rel="alternate"></link><updated>2016-04-22T00:00:00-04:00</updated><author><name>Philipp Kats</name></author><id>tag:casyfill.github.io,2016-04-22:posts/2016/04/dashboard-up-and-running-part-i/</id><summary type="html">&lt;p&gt;In many cases you want to publish either results of your work, documentation or specific tool in the web. While there are tons of hosting services, it is quite convenient to start publishing your static pages, e.g. all html, css and javascript is pre-generated. This does not mean that data is required to be static: you can point to the outer source of data (which is the best practice anyway).&lt;/p&gt;
&lt;p&gt;Among other advantages of this approach, most useful is that it fully copy with "Continious integration" idea, — you can constantly add new features and work on your project, while (either all or selected) commits will be automatically broadcasted.&lt;/p&gt;
&lt;p&gt;There are two main options of publshing on github: &lt;code&gt;project gh-pages&lt;/code&gt; and &lt;code&gt;account page&lt;/code&gt;. Obviously, there is room for only one account page, so lets stick with gh-pages.&lt;/p&gt;
&lt;p&gt;So, let's do it:&lt;/p&gt;
&lt;h3&gt;1. create a repo&lt;/h3&gt;
&lt;p&gt;Start with &lt;code&gt;git init&lt;/code&gt; in the project folder, then create a repository on the github without anything (nor README nor license), and copy the second option code from new github repo to your command line and execute. check Github.&lt;/p&gt;
&lt;p&gt;OR create a repo  on the github, and clone
- &lt;code&gt;git clone your_repo_https_link&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;1. populate with content&lt;/h3&gt;
&lt;h3&gt;2. create a gh-pages orphan branch&lt;/h3&gt;
&lt;h3&gt;3. check if broadcasting works&lt;/h3&gt;
&lt;h3&gt;4. if you need, sync main branch push with gh-pages push. This will make each new edit to be broadcasted&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/5807459/github-mirroring-gh-pages-to-master/7472481#7472481"&gt;source&lt;/a&gt;
Go to the repository &lt;code&gt;.git/config&lt;/code&gt;:
    &lt;code&gt;subl .git/config&lt;/code&gt; or &lt;code&gt;nano .git/config&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Add the following 2 lines to the [remote "origin"] section:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;push = +refs/heads/master:refs/heads/gh-pages
push = +refs/heads/master:refs/heads/master
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And you're done!&lt;/p&gt;</summary><category term="github"></category><category term="dashboard"></category></entry><entry><title>Developing the package using conda, sphynx, and pyscaffold.</title><link href="http://casyfill.github.io/posts/2016/04/developing-the-package-using-conda-sphynx-and-pyscaffold/" rel="alternate"></link><updated>2016-04-21T00:00:00-04:00</updated><author><name>Philipp Kats</name></author><id>tag:casyfill.github.io,2016-04-21:posts/2016/04/developing-the-package-using-conda-sphynx-and-pyscaffold/</id><summary type="html">&lt;p&gt;Creating a module might be tedious, especially if we want to test and document it. Fortunately, there is a large set of tools and services that helps us to copy with such a task, installed properly. In fact, once package deployed correctly, everything else is very simple.&lt;/p&gt;
&lt;p&gt;This memo is compiled partly from presentation and tutorial by Mohit Sharma, and several other sources, like &lt;a href="http://uoa-eresearch.github.io/eresearch-cookbook/recipe/2014/11/20/conda/"&gt;this&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;I. Creating conda environment&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;go to the project folder&lt;/li&gt;
&lt;li&gt;create env: &lt;code&gt;conda create -n yourenvname python=x.x anaconda&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;activate env: &lt;code&gt;source activate yourenvname&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;install packages: &lt;ul&gt;
&lt;li&gt;sphinx: &lt;code&gt;conda install -n yourenvname sphinx&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;pyscaffold: &lt;code&gt;conda install -n yourenvname -c https://conda.anaconda.org/ioos pyscaffold&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;setuptools: &lt;code&gt;conda install -n project setuptools&lt;/code&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can also add &lt;a href="https://tox.readthedocs.org/en/latest/"&gt;Tox&lt;/a&gt; as integration.&lt;/p&gt;
&lt;h2&gt;II. Create sceleton&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;lets generate module seceleton directory: &lt;code&gt;putup -l 'mit' project  --with-travis&lt;/code&gt;. Skeleton in this case starts with git initialized and test folder preapared for Travis integration.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;III. Documentation&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;go to the folder&lt;/li&gt;
&lt;li&gt;run &lt;code&gt;sphinx-quickstart&lt;/code&gt; to generate html documentation&lt;/li&gt;
&lt;li&gt;more info &lt;a href="http://www.sphinx-doc.org/en/stable/tutorial.html"&gt;here&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;IV. Git Repository and Integration&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;now you can create repository on the gitHub and connect to local environment&lt;/li&gt;
&lt;li&gt;to syncronise your repo with travis, comment line31, 32 in &lt;code&gt;tests/travis_install.sh&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;setup coverall&lt;/li&gt;
&lt;li&gt;enjoy (and start checking the documentation)&lt;/li&gt;
&lt;/ul&gt;</summary><category term="CI"></category><category term="travisCI"></category><category term="conda"></category><category term="pyscaffold"></category></entry></feed>